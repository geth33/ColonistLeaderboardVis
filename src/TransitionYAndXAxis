useEffect(() => {
    let t = -1;
  const n = 40;
  const duration = 750;
  const data = d3.range(n).map(next);
  
  function next(previousValue) {
    // Calculate a random change within the range of -30 to 30
    const randomChange = (Math.random() - 0.5) * 60; // Â±30
  
    // Calculate the new value within the range of 1600 to 2000
    let newValue = previousValue + randomChange;
    newValue = Math.max(1600, Math.min(2000, newValue)); // Clamp within the range
  
    return { time: ++t, value: newValue };
  }
  
  // Initialize the data array with the first object
  data[0] = { time: 0, value: 1600 + Math.random() * 400 };
  
  // Generate the rest of the data points based on the previous value
  for (let i = 1; i < n; i++) {
    data[i] = next(data[i - 1].value);
  }
  
  // Define margin, width, and height
  const margin = { top: 6, right: 0, bottom: 20, left: 40 };
  const width = 560 - margin.right;
  const height = 120 - margin.top - margin.bottom;
  
  // Create scales
  const x = d3.scaleLinear()
      .domain([t - n + 1, t])
      .range([0, width]);
  
  const y = d3.scaleLinear()
      .domain([1600, 2000])
      .range([height, 0]);
  
  // Create a line generator
  const line = d3.line()
      .curve(d3.curveBasis) // Use a curve type instead of "interpolate"
      .x((d, i) => x(d.time))
      .y((d) => y(d.value));
  
  // Create an SVG container
  const svg = d3.select(".coreVisContainer")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .style("margin-left", -margin.left + "px")
      .append("g")
      .attr("transform", `translate(${margin.left}, ${margin.top})`);
  
  svg.append("defs").append("clipPath")
      .attr("id", "clip")
      .append("rect")
      .attr("width", width)
      .attr("height", height);
  
  const xAxis = d3.axisBottom(x);
  const xAxisGroup = svg.append("g")
      .attr("class", "x axis")
      .attr("transform", `translate(0, ${height})`)
      .call(xAxis);
  
  const yAxis = d3.axisLeft(y).ticks(4);
  const yAxisGroup = svg.append("g")
      .attr("class", "y axis")
      .call(yAxis);
      //test
  
  const path = svg.append("g")
      .attr("clip-path", "url(#clip)")
      .append("path")
      .datum(data) // Use datum to bind data
      .attr("class", "line");

  function toggleYScaleDomain() {
    const currentDomain = y.domain();
    if (currentDomain[0] === 1400 && currentDomain[1] === 2200) {
        y.domain([1600, 2000]);
    } else {
        y.domain([1400, 2200]);
    }
}

setInterval(() => {
  toggleYScaleDomain();
}, 2000);

setInterval(() => {
  // Update your visualization with the new yScale
  // This could include transitioning your y-axis, redrawing the line, etc.
  // For example:
  x.domain([t - n + 2, t]);
  yAxisGroup.transition()
      .duration(750)
      .call(yAxis);
  xAxisGroup.transition()
      .duration(750)
      .ease(d3.easeLinear) // Use ease function
      .call(xAxis);
  path.transition()
      .duration(750)
      .ease(d3.easeLinear)
      .attr("d", line)
      .attr("transform", `translate(${x(t - n)}, 0)`);
      t++;
}, 750);
  
  }, []);